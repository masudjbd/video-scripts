<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/linenumbers.css" media="screen">

    <title>Video Scripts by tylerneylon</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1><a href="../index.html">Learn Lua in an Hour</a></h1>
        <h2>Metatables</h2>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
<!-- 15.1 metatable intro -->

<p>Now we'll cover metatables.</p>
<p>Every table in Lua has an optional property called a <em>metatable</em>.
It's completely separate from the key/value data, and is set
to <code>nil</code> by default.</p>
<p>Metatables allow us to add object-oriented behavior to tables,
among other things.</p>
<p>With metatables, we can overload operations performed
on tables. The most useful operations to overload are the getting
and setting of key/value pairs, which is the only metatable usage
I'll cover carefully in this video.</p>
<!-- 15.2 setting and getting a metatable -->

<p>We can set a table's metatable using the built-in <code>setmetatable</code>
function, like this:</p>
<pre><code>&gt; meta = {a = 1}
&gt; t = setmetatable({}, meta)
</code></pre>
<p>The first parameter is the table whose metatable is being set;
the second is the metatable itself. The first input is also
the return value.</p>
<p>Even though key <code>a</code> exists in the metatable, it doesn't exist
in <code>t</code> itself:</p>
<pre><code>&gt; = t.a
nil
</code></pre>
<p>Only special keys in a metatable can change a table's behavior.
I'll mention a couple of these keys in just a second.</p>
<p>We can get a table's metatable using the built-in <code>getmetatable</code>
function, like this:</p>
<pre><code>&gt; m = getmetatable(t)
&gt; = m == meta
true
</code></pre>
<!-- 15.3 delegating gets -->

<p>Let's change the behavior of <code>t</code> by providing a backup table.
If a key isn't in <code>t</code>, Lua will look for it in the backup.</p>
<pre><code>&gt; backup = {mykey = 100}
&gt; meta.__index = backup
&gt; = t.mykey
100
</code></pre>
<p><code>__index</code>, as a key in a metatable, is known to Lua as
providing a way to handle failed key lookups. If the
<code>__index</code> value is another table, then Lua will use
that other table as a backup location to find
key/value pairs.</p>
<p>Keys already in <code>t</code> itself will overshadow
any values in the backup table, like this:</p>
<pre><code>&gt; t.mykey = 200
&gt; = t.mykey, backup.mykey
200      100
</code></pre>
<p>We'll see in a minute that this functionality enables
a kind of class inheritance behavior.</p>
<!-- 15.4 delegating sets -->

<p>We can also overload a table's behavior when a key/value pair
is set for a new key.</p>
<p>This works by setting a function as the value of the
<code>__newindex</code> key in a metatable. This function
is called by Lua with the table, key, and value
being set as parameters.</p>
<p>Here's an example:</p>
<pre><code>&gt; meta.__newindex = function (t, k, v) print(k, v) end
&gt; t.newkey = 500
newkey    500
</code></pre>
<p>We tried to set a new key in <code>t</code>; <code>t</code>'s metatable
has a <code>__newindex</code> function, so that function is called
instead of setting the value.
Our function could have saved the data somewhere, but
it just printed things out.</p>
<pre><code>&gt; = t.newkey
nil
</code></pre>
<p>The <code>newkey</code> string is still not a key of <code>t</code>.</p>
<p>Setting values on <em>existing</em> keys of <code>t</code> does <em>not</em> call
our <code>__newindex</code> function:</p>
<pre><code>&gt; t.mykey = 600
-- Editor's note: nothing is printed, unlike the last set.
</code></pre>
<p>This <code>__newindex</code> functionality lets us make things like
read-only tables, proxy tables, or tables that take action on
every data access to them.</p>
<!-- 15.5 rawget and rawset -->

<p>There are two built-in functions called <code>rawget</code> and <code>rawset</code>
which can access a table's data while ignoring its metatable.</p>
<pre><code>&gt; -- rawget, rawset
</code></pre>
<p>I won't cover these functions in detail, but I wanted to let
you know they exist.</p><a href="part16.html" style="float:right">Next</a>
      </section>
    </div>

    
    
  </body>
</html>
